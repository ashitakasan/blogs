# 镜像，容器，存储驱动程序
要有效地使用存储驱动程序，您必须了解 Docker 如何构建和存储镜像

## 镜像和层
每个 Docker 映像引用一个只读层列表，这些层代表文件系统差异；层被堆叠在彼此的顶部，以形成容器的根文件系统的基础。Docker 存储驱动程序负责堆叠这些层并提供单个统一视图。  

创建新容器时，可以在底层堆栈顶部添加一个新的，可写的新层。这个层通常被称为"容器层"。对运行的容器所做的所有更改（例如，写入新文件，修改现有文件和删除文件）都将写入此可写容器层，其他底层的层都是只读的。

![](https://docs.docker.com/engine/userguide/storagedriver/images/container-layers.jpg)

### 内容可寻址存储
Docker 1.10 引入了一个新的内容可寻址存储模型，来处理磁盘上的镜像和图层数据。新模型提高了安全性，提供了一种内置方法来避免 ID 冲突，允许许多镜像自由共享他们的图层。  

使用 migrator 镜像升级容器数据：
```Shell
$ sudo docker run --rm -v /var/lib/docker:/var/lib/docker docker/v1.10-migrator
```

## 容器和层
容器和镜像之间的主要区别是顶部可写层，对容器添加新的或修改现有数据的所有写入都存储在此可写层中，当容器被删除时，可写层也被删除。

![](https://docs.docker.com/engine/userguide/storagedriver/images/sharing-layers.jpg)
Docker 存储驱动程序负责启用和管理镜像层和可写容器层。Docker 镜像和容器管理的两个关键技术是可堆叠镜像层和写时复制（COW）。

### 写实复制 (COW)
Docker 对图像和容器使用了写时复制技术。写时复制是一种类似共享和复制的策略，如果一个进程需要修改或写入数据，那么操作系统才会对该进程使用数据的进行复制；只有需要写入的进程才能访问数据副本，所有其他进程继续使用原始数据。  

#### 共享使镜像更小
如果提取的镜像与本地的镜像共享某些镜像图层，则 Docker 守护程序会识别此镜像，并且仅提取其本地尚未存储的图层。  

#### 复制使容器高效
对容器执行的所有写入都存储在可写入容器层中；其他图层是只读（RO）镜像图层，无法更改。当容器中的现有文件被修改时，Docker 使用存储驱动程序执行写入时复制操作。  

AUFS 和 OverlayFS 存储驱动程序的写时复制过程如下：
- 在镜像层中搜索要更新的文件；该过程从顶层开始，并向下工作到基本层
- 对找到的文件的第一个副本执行"复制"操作，"复制"将文件复制到容器自己的可写层
- 在容器的可写层中修改文件的副本

写入大量数据的容器将消耗更多的空间；如果容器需要写很多数据，应该考虑使用一个数据卷。

## 数据卷和存储驱动程序
当容器被删除时，写入到容器中的未存储在数据卷中的任何数据与容器一起被删除。  

数据卷是 Docker 主机文件系统中直接挂载到容器中的目录或文件。数据卷不受存储驱动程序控制，对数据卷的读写将绕过存储驱动程序，并以本机速度运行。容器被删除时，数据卷中的数据会保留。  
<br/>

# 存储驱动程序的选择
Docker 有一个可插拔的存储驱动程序架构，这使您能够灵活地”插入“最适合您的环境和用例的存储驱动程序。每个Docker 存储驱动程序基于 Linux 文件系统或卷管理器

## Docker 存储驱动程序类别
- overlay
- overlay2
- aufs
- btrfs
- devicemapper
- vfs
- zfs

## 存储驱动程序选择
选择存储驱动程序由两点需要注意：
- 没有单个驱动程序非常适合每个用例
- 存储驱动程序正在不断改进和发展

### 稳定性
- 为分配使用默认存储驱动程序，当 Docker 安装时，它会根据系统的配置选择一个默认存储驱动程序
- 遵循 CS 引擎兼容性矩阵中指定的配置

### 经验和专长
选择熟悉的的存储驱动程序，否则使用默认存储驱动

### 未来发展
下图列出了每个存储驱动程序，并提供了对它们的一些优点和缺点的了解
![](https://docs.docker.com/engine/userguide/storagedriver/images/driver-pros-cons.png)  
<br>


# AUFS 实战
AUFS 是 Docker 使用的第一个存储驱动程序，非常稳定，由以下特性：
- 快速启动容器
- 有效利用存储
- 有效利用内存

## 镜像层及 AUFS 共享
AUFS 是一个统一文件系统，它在单个 Linux 主机上占用多个目录，堆叠在彼此之上，并提供单个统一视图；堆栈中的所有目录以及 union 安装点必须都存在于同一 Linux 主机上。AUFS 引用它作为分支堆叠的每个目录。  

在 Docker 中，AUFS union 安装支持镜像分层。AUFS 存储驱动程序使用此 union 装入系统来实现 Docker 镜像层。AUFS 分支对应于 Docker 镜像层。下图显示了基于 ubuntu:latest 镜像的 Docker 容器，此图显示每个镜像层和容器层在 Docker 主机文件系统中表示为 /var/lib/docker/ 下的目录
![](https://docs.docker.com/engine/userguide/storagedriver/images/aufs_layers.jpg)
AUFS 还支持写时复制技术（CoW）

## 使用 AUFS 进行容器读取和写入
Docker 利用 AUFS CoW 技术启用镜像共享并最小化磁盘空间的使用。AUFS 在文件级工作，即所有 AUFS CoW 操作都复制整个文件 - 即使只修改了文件的一小部分。  

如果需要修改文件，AUFS 搜索每个镜像层的文件，搜索顺序是从上到下；找到后，整个文件将被复制到容器的最高可写层。在任何给定容器上每个文件只发生一次复制操作。

## 使用 AUFS 存储驱动程序删除文件
AUFS 存储驱动程序通过在容器的顶层中放置一个 whiteout 文件来从容器中删除文件，whiteout 文件有效地掩盖了下面的只读镜像层中文件的存在。
![](https://docs.docker.com/engine/userguide/storagedriver/images/aufs_delete.jpg)

## 使用 AUFS 存储驱动程序重命名目录
在 AUFS 上不完全支持调用目录的 rename，他返回 EXDEV（不允许跨设备链接），因此应用程序必须设计为可以处理 EXDEV 并回退到"复制和 unlink"策略

## 使用 AUFS 配置 Docker
只能在安装了 AUFS 的 Linux 系统上使用 AUFS 存储驱动程序

## 本地存储和 AUFS
当 dockerd 使用 AUFS 驱动程序运行时，驱动程序会在 /var/lib/docker/aufs/ 下的 Docker 主机的本地存储区域中存储映像和容器

### 镜像
镜像层及其内容存储在 /var/lib/docker/aufs/diff/ 下，/var/lib/docker/aufs/layers/ 目录包含有关如何堆叠镜像层的元数据，此目录包含 Docker 主机上每个镜像或容器层的一个文件。对于 Docker 1.10 和更高版本，镜像层 ID __不__ 与目录名称相对应。

### 容器
运行容器挂载在 /var/lib/docker/aufs/mnt/<container-id> 下，这是将存放容器和所有底层镜像图层作为单个统一视图的 AUFS union 装入点的位置。如果容器没有运行，它有一个空目录，这是因为 AUFS 只在其运行时装载容器。  

容器元数据和放置到正在运行的容器中的各种配置文件存储在 /var/lib/docker/containers/<container-id> 中,此目录中的文件对于系统上的所有容器都存在，包括停止的容器；当容器正在运行时，容器的日志文件也在此目录中。  

容器的可写层存储在 /var/lib/docker/aufs/diff/ 下的目录中，即使容器已停止，目录也存在。这意味着重新启动容器不会丢失对它所做的更改；一旦容器被删除，这个目录中的可写层将被删除。

### AUFS 和 Docker 性能
- AUFS 存储驱动程序是 PaaS 和其他类似用例的理想选择，其中容器压缩很重要
- AUFS 在镜像层和容器之间共享文件的基本机制使用系统页面缓存有效
- AUFS 存储驱动程序的写入性能会有显著的延迟

### AUFS 兼容性
AUFS 不完全支持 rename 系统调用，应用程序需要检测其故障，并回退到"复制和 unlink"策略
