## ZooKeeper 解决方案

### ZooKeeper 自带：命名服务，配置，集群成员
命名服务和配置是 ZooKeeper 的两个主要应用程序，由 ZooKeeper API 直接提供  
ZooKeeper 也支持集群成员；组由节点表示，组的成员在组节点下创建临时节点，当节点失效时删除临时节点

### Barriers
通过指定屏障节点，在 ZooKeeper 中实现屏障：
1. 客户端在屏障节点上调用 ZooKeeper API 的exists() 函数，并将 watch 设置为 true
2. 如果 exists() 返回 false，则屏障消失，客户端继续执行
3. 如果 exists() 返回 true，则客户端等待来自 ZooKeeper 的删除屏障节点的监视事件
4. 当触发 watch 事件时，客户端重新发出 exists() 调用，再次等待，直到屏障节点被删除

#### 双重屏障
双重屏障使客户端能够同步计算的开始和结束，当足够的进程加入屏障时，进程开始计算，一旦完成就离开屏障  
节点通过下面的 Enter 向屏障节点注册，它在进行计算之前等待直到 x 个客户端进程注册
```TXT
1. 创建屏障节点 b
2. 设置监视器：exists(b + "/ready", true)
3. 创建子节点：create( n, EPHEMERAL)
4. L = getChildren(b, false)
5. 如果子节点数目小于 x，则继续等待节点事件
6. 否则，创建 "/ready" 子节点：create(b + ‘‘/ready’’, REGULAR)
```
```TXT
1. L = getChildren(b, false)
2. 如果没有子节点，退出
3. 如果 p 是 L 中唯一的进程节点，则删除该子节点并退出
4. 如果 p 是 L 中最小的子节点，则等待较大的节点删除
5. 否则，删除该子节点，并等待 L 中最小的子节点删除
```

### 队列
首先指定一个 znode 来保存队列，即队列节点；队列生产者调用 create() 创建队列节点的子节点 queue-X，其中 X 为递增的数字；队列消费者调用 getChildren() 函数，并在队列节点上将 watch 设置为 true，并开始处理具有最小编号的节点，以保证队列的先进先出；每次删除一个队列资源就从队列节点上删除相应的子节点，消费完本地队列列表再调用 getChildren() 重新获取子节点列表。

#### 优先队列
要实现优先级队列，只需对通用队列进行两个简单的更改即可：
- 添加到队列节点的子节点以"queue-YY"命名，其中 YY 为优先级，数值越小优先级越高
- 如果消费者收到了队列节点的子节点更改通知，则重新调用 getChildren()，更新本地子节点列表

### 锁
全分布式锁的全局同步，意味着在任何时刻，只有一个客户端持有锁  

希望获得锁的客户端执行以下操作：
1. 调用 create() 创建子节点 "lock-"，并设置序列和临时标志，保存自己创建的节点名
2. 在锁节点上调用 getChildren() 而 __不__ 设置 watch 标志
3. 如果在步骤 1 中创建的路径名具有最低的序列号后缀，则客户端持有锁，可退出该协议
4. 客户端在锁目录的下一个最低序列号子节点上调用 exists()，设置 watch
5. 如果 exists() 返回 false，则返回步骤 2；否则等待上一步中子节点的 watch 事件  

如果客户端想释放锁，只需要删除其在步骤 1 中创建的子节点  

`注意：`
- 多个客户端执行的顺序在步骤 1 中就确定了
- 删除节点只会导致一个客户端被唤醒，因为每个节点正好由一个客户端监视
- 没有轮询或超时
- 由于实现锁定的方式，很容易看到锁争用的数量，断开锁，调试锁定问题等

#### 共享锁
可以通过对锁协议进行一些更改来实现共享锁：

##### 获取读锁：
1. 调用 create() 创建一子节点 "read-" 的节点，并设置序列和临时标志
2. 在锁节点上调用 getChildren()，而不设置 watch 标志
3. 如果没有以 "write-" 开头的子节点，并且具有比步骤 1 中创建的节点更低的序列号的子节点，则客户端持有锁，可退出该协议
4. 客户端在锁目录的以 "write-" 开头的下一个最低序列号子节点上调用 exists()，设置 watch
5. 如果 exists() 返回 false，转到步骤 2；否则等待上一步中子节点的 watch 事件

##### 获取写锁：
1. 调用 create() 创建一子节点 "write-" 的节点，并设置序列和临时标志
2. 在锁节点上调用 getChildren()，而不设置 watch 标志
3. 如果没有比在步骤 1 中创建的节点更低的序列号的子节点("write-")，则客户端持有锁，可退出该协议
4. 客户端在锁目录的以 "write-" 开头的下一个最低序列号子节点上调用 exists()，设置 watch
5. 如果 exists() 返回 false，转到步骤 2；否则等待上一步中子节点的 watch 事件

#### 可恢复共享锁
可以通过简单的修改共享锁协议使共享锁可撤销  
在上述步骤 1 中，调用 create() 之后，马上在该节点上调用 getData() 并设置监视器；如果该客户端收到此节点的数据更改的通知，则再次执行 getData() 并设置监视器，通知检查节点数据是否是 "unlock"，该字符串通知客户端释放锁；该协议要求持有锁的客户端同意释放锁。

### 两阶段提交
两阶段提交协议是允许分布式系统中的所有客户端同意提交事务或中止的算法  

ZooKeeper 创建一个事务节点，然后参与事务的每个站点都要创建一个子节点；每个站点需要在事务节点上设置 getChildren() 监视以及在每个子节点上设置 getData() 监视。提交事务时，每个站点通过写入 "commit" 或 "abort" 到自己创建的子节点上，只有所有的站点都写入 "commit" 事务才能整体提交；注意如果有一个站点写入 "abort"，其他站点可以提前中止事务。  

上述实现有两个缺点：
- 消息复杂度是 O(n^2)
- 不能通过临时节点来检测站点故障
为了解决第一个问题，可以只让协调器通知事务节点的更改，然后一旦协调器达到决定的点，通知站点  
为了解决第二个问题，可以让协调器将事务传播到站点，并让每个站点创建其自己的临时节点

### 领导选举
使用 ZooKeeper 进行领导选举的一种简单方法，是在创建代表客户端 "建议" 的 znode 时使用 `SEQUENCE | EPHEMERAL` 标志。领导选举需要有一个领导节点 "/election"，每个客户端创建一个子节点 "/election/n_"，标志 SEQUENCE | EPHEMERAL，创建具有最小附加序列号的 znode 的进程是 leader。  

更重要的是要注意领导者的失败，以便在当前领导者失败的情况下，新的客户端成为新的领导者。一个简单的解决方案是让所有应用程序进程监视当前最小的 znode 即领导，领导失效时被自动删除，于是当前最小的 znode 是新的领导者。为了避免群体效应，监视子节点序列上的下一个 znode 就足够了。如果客户端接收到它正在监视的 znode 消失的通知，则该客户端在没有更小的 znode 的情况下变为新的领导者。
