## 原子广播
ZooKeeper 的核心是一个原子消息系统，使所有的服务器保持同步

### 保证，属性和定义
ZooKeeper 的消息传递系统提供的如下保证：
- __可靠的分发__ 如果消息 m 由一个服务器发布，则它将最终向所有服务器发布
- __总体排序__ 如果一个服务器的消息 a 在消息 b 之前发布，则 a 在 b 之前向所有的服务器发布
- __因果秩序__ 如果消息 b 在消息 a 被递送到 b 的发送者之后才发送，则 消息 a 必须排在 b 前边

### 领导者激活
领导激活包括领导选举，目前在 ZooKeeper 中有两个领导选举算法：LeaderElection 和 FastLeaderElection  

基本操作规则：
- 跟随者在与领导者同步之后将确认 NEW_LEADER 投标
- 跟随者将仅确认具有给定 zxid 的 NEW_LEADER 提议的单个服务器
- 当一个法定人数的成员确认 NEW_LEADER 提案时，新的领导者将提交该提案
- 当 NEW_LEADER 提议是 COMMIT 时，跟随者将提交从领导者接收的任何状态
- 在 NEW_LEADER 投标已被 COMMITED 之前，新的领导者将不接受新投标

如果领导选举错误地终止，我们没有问题，因为 NEW_LEADER 建议不会被提交，因为领导不会有仲裁

### 激活消息
ZooKeeper 消息的操作类似于经典的两阶段提交  

所有通信通道都是 FIFO，所以一切都按顺序完成
- 领导者使用相同的顺序向所有关注者发送建议
- 关注者按收到消息的顺序处理消息
- 领导者将在法定人数的成员确认消息后立即向所有关注者发出 COMMIT
- 提交按顺序处理，当提交提交时，追随者会提交提案消息

## 日志
Zookeeper 使用 slf4j 作为日志记录的抽象层，现在选择版本1.2中的 log4j 作为最终日志记录实现

### 日志级别
- `ERROR` 指定可能仍然允许应用程序继续运行的错误事件
- `WARN` 表示潜在的有害情况
- `INFO` 指定以粗粒度级别突出应用程序进度的信息性消息
- `DEBUG` 指定对调试应用程序最有用的细粒度信息事件
- `TRACE` 指定比DEBUG更细粒度的信息事件

生成环境中，Zookeeper 通常以 INFO 或更高级别输出日志
